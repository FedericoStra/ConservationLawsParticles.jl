export SampledInteraction, IntegratedInteraction
export sampled_interaction, integrated_interaction, compute_interaction
export SI, II


@doc raw"""
    sampled_interaction([t,] x, W′, ys)

Computes ``-(W' * \dot\rho)(t, x)``, which is the sampled approximation of ``-(W' * \rho)(t, x)``,
where ``\rho`` is the piecewise-constant density associated to the particles `ys`.

It `t` is omitted, then `W′(x)` is assumed independent of time.

See also [`integrated_interaction`](@ref), [`compute_interaction`](@ref).
"""
function sampled_interaction end

function sampled_interaction(x::Real, Wprime, ys::AbstractVector{<:Real})
    -sum(y -> Wprime(x - y), ys) / (length(ys) - 1)
end

function sampled_interaction(t::Real, x::Real, Wprime, ys::AbstractVector{<:Real})
    -sum(y -> Wprime(t, x - y), ys) / (length(ys) - 1)
end

function sampled_interaction(x::Real; Wprime, particles::AbstractVector{<:Real})
    -sum(p -> Wprime(x - p), particles) / (length(particles) - 1)
end

function sampled_interaction(t::Real, x::Real; Wprime, particles::AbstractVector{<:Real})
    -sum(p -> Wprime(t, x - p), particles) / (length(particles) - 1)
end


@doc raw"""
    integrated_interaction([t,] x, W, ys[, dens_diff])

Computes ``-(W' * \rho)(t, x) = -(W * \rho')(t,x)``, where ``\rho`` is the piecewise-constant
density associated to the particles `ys`.

It `t` is omitted, then `W(x)` is assumed independent of time.

!!! note

    To ensure the correctness of the computation, `dens_diff` must coincide with `diff(pwc_density(ys))`.
    It can be pre-computed and passed explicitly to allow reuse (as an optimization).

See also [`sampled_interaction`](@ref), [`compute_interaction`](@ref).
"""
function integrated_interaction end

function integrated_interaction(x::Real, W, ys::AbstractVector{<:Real}, dens_diff::AbstractVector{<:Real}=diff(pwc_density(ys)))
    # eachindex(dens_diff) == eachindex(ys) || throw(DimensionMismatch("`ys` and `dens_diff` must have the same indices"))
    # -sum(i -> (@inbounds W(x - ys[i]) * dens_diff[i]), eachindex(ys, dens_diff))
    -sum(p -> W(x - p[1]) * p[2], zip(ys, dens_diff))
end

function integrated_interaction(t::Real, x::Real, W, ys::AbstractVector{<:Real}, dens_diff::AbstractVector{<:Real}=diff(pwc_density(ys)))
    # eachindex(dens_diff) == eachindex(ys) || throw(DimensionMismatch("`ys` and `dens_diff` must have the same indices"))
    # -sum(i -> (@inbounds W(t, x - ys[i]) * dens_diff[i]), eachindex(ys, dens_diff))
    -sum(p -> W(t, x - p[1]) * p[2], zip(ys, dens_diff))
end


"""
    SampledInteraction(W′)

Represents the sampled interaction induced by the function `W′`.

The interaction can be evaluated with [`compute_interaction`](@ref).

See also [`IntegratedInteraction`](@ref).
"""
struct SampledInteraction{TWprime}
    Wprime::TWprime
end

"""
    IntegratedInteraction(W)

Represents the integrated interaction induced by the function `W`.

The interaction can be evaluated with [`compute_interaction`](@ref).

See also [`SampledInteraction`](@ref).
"""
struct IntegratedInteraction{TW}
    W::TW
end

"""
    compute_interaction(t, x, interaction, ys[, dens_diff])

Evaluates the interaction generated by the particles `ys` at `(t, x)`.

`interaction` can be a `SampledInteraction`, an `IntegratedInteraction`, or any other
form of interaction that provides this interface.

See also [`SampledInteraction`](@ref), [`IntegratedInteraction`](@ref),
[`sampled_interaction`](@ref), [`integrated_interaction`](@ref).
"""
function compute_interaction end

function compute_interaction(t::Real, x::Real, int::SampledInteraction, ys::AbstractVector{<:Real}, dens_diff::AbstractVector{<:Real}=Float16[])
    sampled_interaction(t, x, int.Wprime, ys)
end

function compute_interaction(t::Real, x::Real, int::IntegratedInteraction, ys::AbstractVector{<:Real}, dens_diff::AbstractVector{<:Real}=diff(pwc_density(ys)))
    integrated_interaction(t, x, int.W, ys, dens_diff)
end


const SI = SampledInteraction
const II = IntegratedInteraction
